#
# FILE: Chat004_Directory-Lister-Script_20250818_143500.py.backup.backup
# WORKING_DIRECTORY: C:/Users/Wales/OneDrive/Desktop/PROGRESSIVE_FRAMEWORK-Set-2/B2 Optimised 16_08_2025
# PURPOSE: Progressive Framework System Component
# CREATOR: Amos Wales - Progressive Framework Pioneer
# UPDATED: 20250819_Progressive-Framework-Integration
# STATUS: ‚úÖ Progressive Framework System File
# BREATHING_FRAMEWORK: 15 Systems ‚úÖ | 615+ Tests ‚úÖ | System Integration ‚úÖ
# PROGRESSIVE_FRAMEWORK: System_Related | Confidence: 30 | System Validated ‚úÖ
#

#!/usr/bin/env python3
"""
Directory Lister Script for Framework Set 2 Project
FILE: Chat004_Directory-Lister-Script_20250818_143500.py
PURPOSE: List directory structure and all files with detailed information
CREATOR: Amos Wales - Progressive Framework Pioneer
CREATED: 20250818_143500
"""

import os
import sys
from pathlib import Path
import datetime
from typing import List, Dict, Optional
import argparse

class DirectoryLister:
    """Enhanced directory listing with Framework Set 2 project awareness"""
    
    def __init__(self, root_path: str):
        self.root_path = Path(root_path).resolve()
        self.total_files = 0
        self.total_dirs = 0
        self.total_size = 0
        self.file_types = {}
        
    def format_size(self, size_bytes: int) -> str:
        """Convert bytes to human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f} PB"
    
    def get_file_info(self, file_path: Path) -> Dict:
        """Get detailed file information"""
        try:
            stat = file_path.stat()
            return {
                'name': file_path.name,
                'size': stat.st_size,
                'size_formatted': self.format_size(stat.st_size),
                'modified': datetime.datetime.fromtimestamp(stat.st_mtime).strftime('%Y-%m-%d %H:%M:%S'),
                'extension': file_path.suffix.lower(),
                'is_framework_file': self.is_framework_file(file_path)
            }
        except (OSError, PermissionError):
            return {
                'name': file_path.name,
                'size': 0,
                'size_formatted': 'Permission Denied',
                'modified': 'Unknown',
                'extension': file_path.suffix.lower(),
                'is_framework_file': False
            }
    
    def is_framework_file(self, file_path: Path) -> bool:
        """Check if file is related to Framework Set 2"""
        framework_keywords = [
            'framework', 'progressive', 'pdt-plus', 'puxt-plus', 'pso-prime',
            'pmcs-024', 'paes', 'atlas', 'prism', 'nexus', 'crud',
            'debugging', 'engine', 'fusion', 'intelligence', 'evolution',
            'orchestration', 'coordination', 'pkm', 'chat', 'system'
        ]
        
        filename_lower = file_path.name.lower()
        return any(keyword in filename_lower for keyword in framework_keywords)
    
    def list_directory_tree(self, show_hidden: bool = False, max_depth: Optional[int] = None) -> str:
        """Generate directory tree listing"""
        output = []
        output.append(f"üìÅ DIRECTORY STRUCTURE: {self.root_path}")
        output.append("=" * 80)
        output.append("")
        
        def walk_directory(path: Path, prefix: str = "", depth: int = 0):
            if max_depth is not None and depth > max_depth:
                return
                
            try:
                items = list(path.iterdir())
                if not show_hidden:
                    items = [item for item in items if not item.name.startswith('.')]
                
                # Sort: directories first, then files
                dirs = sorted([item for item in items if item.is_dir()])
                files = sorted([item for item in items if item.is_file()])
                
                all_items = dirs + files
                
                for i, item in enumerate(all_items):
                    is_last = i == len(all_items) - 1
                    current_prefix = "‚îî‚îÄ‚îÄ " if is_last else "‚îú‚îÄ‚îÄ "
                    next_prefix = prefix + ("    " if is_last else "‚îÇ   ")
                    
                    if item.is_dir():
                        self.total_dirs += 1
                        framework_indicator = "üîß" if self.is_framework_file(item) else "üìÅ"
                        output.append(f"{prefix}{current_prefix}{framework_indicator} {item.name}/")
                        walk_directory(item, next_prefix, depth + 1)
                    else:
                        file_info = self.get_file_info(item)
                        self.total_files += 1
                        self.total_size += file_info['size']
                        
                        # Track file types
                        ext = file_info['extension']
                        self.file_types[ext] = self.file_types.get(ext, 0) + 1
                        
                        # File indicators
                        if file_info['is_framework_file']:
                            file_indicator = "‚ö°"  # Framework Set 2 related
                        elif ext in ['.md', '.txt']:
                            file_indicator = "üìÑ"  # Documentation
                        elif ext in ['.py', '.js', '.ts', '.json']:
                            file_indicator = "üíª"  # Code files
                        elif ext in ['.xml', '.yaml', '.yml']:
                            file_indicator = "‚öôÔ∏è"   # Configuration
                        else:
                            file_indicator = "üìé"  # Other files
                        
                        output.append(f"{prefix}{current_prefix}{file_indicator} {item.name} "
                                    f"({file_info['size_formatted']}) - {file_info['modified']}")
                        
            except PermissionError:
                output.append(f"{prefix}‚îî‚îÄ‚îÄ ‚ùå Permission Denied")
        
        walk_directory(self.root_path)
        return "\n".join(output)
    
    def generate_summary(self) -> str:
        """Generate summary statistics"""
        output = []
        output.append("")
        output.append("üìä DIRECTORY SUMMARY")
        output.append("=" * 80)
        output.append(f"üìÅ Total Directories: {self.total_dirs}")
        output.append(f"üìÑ Total Files: {self.total_files}")
        output.append(f"üíæ Total Size: {self.format_size(self.total_size)}")
        output.append("")
        
        if self.file_types:
            output.append("üìã FILE TYPES:")
            sorted_types = sorted(self.file_types.items(), key=lambda x: x[1], reverse=True)
            for ext, count in sorted_types:
                ext_display = ext if ext else "(no extension)"
                output.append(f"   {ext_display}: {count} files")
        
        return "\n".join(output)
    
    def generate_framework_files_report(self) -> str:
        """Generate report of Framework Set 2 related files"""
        output = []
        output.append("")
        output.append("‚ö° FRAMEWORK SET 2 FILES")
        output.append("=" * 80)
        
        framework_files = []
        
        def find_framework_files(path: Path):
            try:
                for item in path.iterdir():
                    if item.is_file() and self.is_framework_file(item):
                        file_info = self.get_file_info(item)
                        framework_files.append((item, file_info))
                    elif item.is_dir() and not item.name.startswith('.'):
                        find_framework_files(item)
            except PermissionError:
                pass
        
        find_framework_files(self.root_path)
        
        if framework_files:
            framework_files.sort(key=lambda x: x[1]['modified'], reverse=True)
            for file_path, file_info in framework_files:
                relative_path = file_path.relative_to(self.root_path)
                output.append(f"‚ö° {relative_path}")
                output.append(f"   Size: {file_info['size_formatted']} | Modified: {file_info['modified']}")
                output.append("")
        else:
            output.append("No Framework Set 2 related files found.")
        
        return "\n".join(output)

def main():
    """Main function with command line argument support"""
    parser = argparse.ArgumentParser(
        description='List directory structure for Framework Set 2 project',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python directory_lister.py
  python directory_lister.py --path "C:\\Your\\Custom\\Path"
  python directory_lister.py --hidden --max-depth 3
  python directory_lister.py --output directory_structure.txt
        """
    )
    
    parser.add_argument(
        '--path', '-p',
        default='.',
        help='Path to analyze (default: current directory)'
    )
    
    parser.add_argument(
        '--hidden', '-a',
        action='store_true',
        help='Include hidden files and directories'
    )
    
    parser.add_argument(
        '--max-depth', '-d',
        type=int,
        help='Maximum depth to traverse'
    )
    
    parser.add_argument(
        '--output', '-o',
        help='Output file (default: print to console)'
    )
    
    parser.add_argument(
        '--framework-only', '-f',
        action='store_true',
        help='Show only Framework Set 2 related files'
    )
    
    args = parser.parse_args()
    
    # Validate path
    target_path = Path(args.path).resolve()
    if not target_path.exists():
        print(f"‚ùå Error: Path '{target_path}' does not exist")
        sys.exit(1)
    
    if not target_path.is_dir():
        print(f"‚ùå Error: Path '{target_path}' is not a directory")
        sys.exit(1)
    
    # Create lister and generate output
    lister = DirectoryLister(str(target_path))
    
    output_lines = []
    
    # Header
    output_lines.append("üîß PROGRESSIVE FRAMEWORK SET 2 - DIRECTORY ANALYSIS")
    output_lines.append(f"Generated: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    output_lines.append(f"Path: {target_path}")
    output_lines.append("")
    
    if not args.framework_only:
        # Full directory listing
        output_lines.append(lister.list_directory_tree(args.hidden, args.max_depth))
        output_lines.append(lister.generate_summary())
    
    # Framework files report
    output_lines.append(lister.generate_framework_files_report())
    
    # Output results
    full_output = "\n".join(output_lines)
    
    if args.output:
        try:
            with open(args.output, 'w', encoding='utf-8') as f:
                f.write(full_output)
            print(f"‚úÖ Output saved to: {args.output}")
        except IOError as e:
            print(f"‚ùå Error writing to file: {e}")
            sys.exit(1)
    else:
        print(full_output)

if __name__ == "__main__":
    main()